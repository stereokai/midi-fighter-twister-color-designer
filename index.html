<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>MIDI Fighter Twister Color Designer</title>
  <meta name="description" content="Color designer for MIDI Fighter Twister">
  <meta name="author" content="Stereokai">
  <script src="https://cdn.jsdelivr.net/npm/webmidi@2.5.2/webmidi.min.js"></script>
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>

<body>
  <div>
    <button id="copy">Copy colors to clipboard</button>
    <button id="reset">Reset</button>
  </div>

  <label>channel
    <input id="channel" type="number" min="1" max="16" value="2">
  </label>

  <label>bank
    <input id="bank" type="number" min="1" max="4" value="1">
  </label>
  
  <div>Connection status: <span style="font-weight: bold; color: firebrick" id="status">Disconnected</span></div>
  
  <script>
const MFT = "Midi Fighter Twister";
const statusIndicator = document.querySelector('#status');
let controllers = getFreshState();
let isConnected = false;
    
WebMidi.enable(err => {
  if (err) {
    console.log("Error: WebMidi could not be enabled.", err);
  } else {
    WebMidi.addListener("connected", e => {
      if (e && e.port && e.port.name === MFT) {
        if (getInput()) {
          if (isConnected) { return; }
          
          setConnectionStatus(true);
          getInput().addListener('controlchange', 'all', e => {
            if (!isConnected) { return; }
            
            const controller = e.controller.number;
            const value = e.value;
            getOutput().sendControlChange(controller, value, getChannel());
             
            // Set bank automatically
            const currentBank = (controller / 16 | 0) + 1; // Which bank are we on?
            setBank(currentBank);
            
            controllers[controller % 16].value = value;
            controllers[controller % 16].touched = true;
          });
        }
      }
    });

    WebMidi.addListener("disconnected", e => {
      if (e && e.port && e.port.name === MFT) {
        setConnectionStatus(false);
      }
    });
  }
});
    
function getFreshState() {
  return Array.from({
    length: 16
  }, () => ({
    touched: false,
    value: 0
  }));
}
    
function getInput() {
  return WebMidi.getInputByName(MFT);
}

function getOutput() {
  return WebMidi.getOutputByName(MFT);
}
    
function decToHex(number) {
  return number.toString(16).toUpperCase().padStart(2, '0');
}

function setConnectionStatus(status) {
  if (status) {
    isConnected = true;
    statusIndicator.innerText = "Connected";
    statusIndicator.style.color = "limegreen";
  } else {
    isConnected = false;
    statusIndicator.innerText = "Disconnected";
    statusIndicator.style.color = "firebrick";
  }
}

function getChannel() {
  return (document.querySelector("#channel").value | 0) || 2; // Default color channel
}
    
function getChannelMidi() {
  const minMidiChannel = 175;
  let channel = document.querySelector("#channel").value | 0;
  return decToHex(minMidiChannel + getChannel());
}

function setBank(bank) {
  if (bank >= 1 && bank <= 4) {
    document.querySelector("#bank").value = bank;
    return true;
  }
  
  return false;
}

function getBank() {
  return document.querySelector("#bank").value | 0;
}

function getBankOffset() {
  return (getBank() - 1) * 16;
}

function getRealControllerIndex(controllerIndex) {
  return controllerIndex + getBankOffset();
}
    
function getMidiMessage(controllerIndex, value) {
  return `${getChannelMidi()} ${decToHex(getRealControllerIndex(controllerIndex))} ${decToHex(value)}`;
}

function getColorSchemeMidi() {
  return controllers.map((controller, controllerIndex) => {
    if (!controller.touched) return false;
    return getMidiMessage(controllerIndex, controller.value);
  }).filter(c => c).join(' ');
}

function copyColorScheme() {
  const scheme = getColorSchemeMidi();
  debugger
  if (!scheme) {
    window.alert("Nothing to copy, make some changes!");
    return;
  }
                 
  (async () => {
    const result = await navigator.permissions.query({
      name: 'clipboard-write'
    });
    
    if (result.state == 'granted' || result.state == 'prompt') {
      try {
        await navigator.clipboard.writeText(scheme);
        window.alert('Colors MIDI copied to clipboard!');
      } catch (err) {
        console.error('Error: Failed to copy, ', err);
      }
    } else {
      console.log('Error: no permission to copy');
    }
  })();
}
    
function reset() {
  controllers = getFreshState();
  controllers.forEach((controller, controllerIndex) => {
    getOutput().sendControlChange(getRealControllerIndex(controllerIndex), 0, getChannel()); 
  });
}

document.querySelector('#copy').onclick = copyColorScheme;
document.querySelector('#reset').onclick = reset;
  </script>
</body>
</html>
